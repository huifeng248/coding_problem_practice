def parenthetical_possibilities(s):
  if len(s) == 0:
    return [""]
  
  res = []
  choices, reminder = word_handling(s)
  # print("choices", choices)
  # print("reminder", reminder)
  for choice in choices:
    # print("choices", choices)
    reminder_choices = parenthetical_possibilities(reminder)
    # print("reminder_choices", reminder_choices)
    for reminder_choice in reminder_choices:
      res.append(choice + reminder_choice)
  
  return res 

  
  

def word_handling(string):
  if string[0] == "(":
    end = string.index(")")
    choices = string[1:end]
    reminder = string[end+1:]
    return (choices, reminder)
  else:
    return (string[0], string[1:])
  
print(parenthetical_possibilities("(qr)ab(stu)c"))
# print(word_handling("sassss"))


# parenthetical possibilities
# Write a function, parenthetical_possibilities, that takes in a string as an argument. The function should return an array containing all of the strings that could be generated by expanding all parentheses of the string into its possibilities.

# For example, the possibilities for 'x(mn)yz' are 'xmyz', 'xnyz'.

# test_00:
parenthetical_possibilities('x(mn)yz') # -> 
# [ 'xmyz', 'xnyz' ]
# test_01:
parenthetical_possibilities("(qr)ab(stu)c") # ->
# [ 'qabsc', 'qabtc', 'qabuc', 'rabsc', 'rabtc', 'rabuc' ]


def parenthetical_possibilities(s):
  if len(s) == 0:
    return ['']
  remaining, chars = get_options(s)
  suffixes = parenthetical_possibilities(remaining)
  possibilities = []
  for char in chars:
    possibilities += [ char + suffix for suffix in suffixes ]
  return possibilities
  
def get_options(s):
  if s[0] == '(':
    idx = s.index(')')
    chars = s[1:idx]
    remaining = s[idx + 1:]
    return ( remaining, chars )
  else:
    chars = s[0]
    remaining = s[1:]
    return ( remaining, chars )
# n = length of the string, m = length of largest parenthetical group
# Time: ~O(m^n)
# Space: ~O(m^n)

